---
id: agents
title: Agent Orchestration
description: How LangGraph memory, guardrails, and Supabase-backed tools coordinate autonomous research agents.
---

## Overview

The primary agent entry point is `agents/langgraph_chain.py`, which adheres to the guardrails and role expectations defined in `AGENTS.md`. The module exposes `build_planner()` and `run_planner()` helpers that compile a LangGraph `StateGraph` with a durable `MemorySaver` checkpointer. Each invocation loads or persists context through Supabase so tool outcomes can be replayed. For a system-wide reference, see [`docs/architecture/quant_ai_strategy_design.md`](architecture/quant_ai_strategy_design.md).

### Planner State & Memory

- **Context dictionary** – `PlannerState.context` carries the incoming request (`intent`, `payload`, optional `model`) along with execution metadata such as `agent_id`, `planned_tool`, and `validated_paths`.
- **History window** – The last five tool calls are appended to `PlannerState.history` (and mirrored to `long_term_state.history`) with timestamps so subsequent decisions can reason about recent activity.
- **Metrics cache** – If a tool returns structured metrics (for example Sharpe ratios from `run_backtest`), they are stored in `PlannerState.metrics` and persisted to Supabase `agent_state` for downstream dashboards.
- **Durable checkpointing** – `MemorySaver` is configured when `build_planner()` compiles the graph. Passing a stable `thread_id` to `run_planner()` allows the planner to resume long-running conversations or workflows across process restarts.

### Guardrails

Before any Python files generated by a tool (for example `propose_new_feature`) are considered valid, the guardrail node runs `ruff` and `mypy` on the touched paths. Failures raise immediately, preventing the agent from suggesting a commit that would fail CI. Additional paths can be injected through `context.guardrail_paths`.

## Tooling Surface

`ToolNode` wires four Supabase-aware helpers from `agents/tools.py`:

| Tool | Purpose | Supabase Integration |
| --- | --- | --- |
| `propose_new_feature` | Writes versioned modules under `features/` and upserts metadata into `feature_registry` | `record_feature()` helper (id, name, version, path, meta) |
| `run_backtest` | Runs `backtest/engine.py`, uploads summary JSON & plots to storage, records rows in `backtest_results` | Storage uploads + `insert_backtest_result()` (`config`, `metrics`, `artifacts`) |
| `prune_vectors` | Archives stale pgvector rows based on recency, t-stat, and regime coverage | RPC: `rpc_prune_vectors` |
| `refresh_vector_store` | Regenerates TS2Vec embeddings and upserts into `signal_embeddings` | `insert_embeddings()` |

These helpers call into `framework.supabase_client`, which centralizes Supabase credentials, typed payloads, and storage helpers for the rest of the repo.

## Extending the Planner

1. Implement a new tool in `agents/tools.py` that uses Supabase RPCs/tables or Prefect triggers.
2. Wrap the callable with a `StructuredTool` in `agents/langgraph_chain.py` and add it to the ToolNode.
3. Update the docs and relevant Prefect flows so automated orchestration remains in sync.

All tools must return structured dictionaries. Results propagate through `PlannerState.results`, populate memory, and eventually persist via Supabase for auditability.
