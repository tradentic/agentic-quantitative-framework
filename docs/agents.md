---
id: agents
title: Agent Orchestration
description: How LangGraph memory, guardrails, and Supabase-backed tools coordinate autonomous research agents.
---

## Overview

The primary agent entry point is `agents/langgraph_chain.py`, which adheres to the guardrails and role expectations defined in
`AGENTS.md`. The chain wraps a LangGraph `StateGraph` with explicit short-term and long-term memory so that tool outcomes can be
replayed and persisted to Supabase. Durable checkpoints are written to `.cache/langgraph_state.sqlite` via LangGraph's
`SqliteSaver`, keeping per-thread context aligned with the Supabase `agent_state` table.

### State & Memory

- **Short-term context** – The last five tool calls (action, timestamp, result) are retained in `AgentState.short_term_memory` so
  the planner can ground subsequent tool calls without repeated lookups.
- **Long-term memory** – Each agent run looks up state from the Supabase `agent_state` table via `framework.supabase_client` and
  persists updated history and metrics after successful tool execution. This ensures context is shared across invocations and
  stays synchronized with the checkpointer.
- **Metrics tracking** – Tool return payloads populate `AgentState.metrics` and the Supabase record so downstream dashboards have
  ready access to the most recent Sharpe, t-stat, and pruning outcomes.

### Guardrails

Before any Python files generated by a tool (for example `propose_new_feature`) are considered valid, the guardrail node runs
`ruff check` and `mypy` on the touched paths. Failing either command raises immediately, preventing the agent from suggesting a
commit that would fail CI. Additional paths can be injected through `task_context.guardrail_paths`.

## Tooling Surface

| Tool | Purpose | Supabase Integration |
| --- | --- | --- |
| `propose_new_feature` | Writes versioned modules under `features/` and upserts metadata into `feature_registry` | `record_feature()` helper |
| `run_backtest` | Runs `backtest/engine.py`, uploads summary JSON & plots to storage, records rows in `backtest_results` | Storage uploads + `insert_backtest_result()` |
| `prune_vectors` | Archives stale pgvector rows based on recency, t-stat, and regime coverage | RPC: `rpc_prune_vectors` |
| `refresh_vector_store` | Regenerates TS2Vec embeddings and upserts into `signal_embeddings` | `insert_embeddings()` |

These helpers call into `framework.supabase_client`, which centralizes Supabase credentials, typed payloads, and storage helpers
for the rest of the repo.

## Extending the Chain

1. Implement a new tool in `agents/tools.py` that uses Supabase RPCs/tables or Prefect triggers.
2. Register the callable in `TOOL_REGISTRY` inside `agents/langgraph_chain.py`.
3. Update the docs and relevant Prefect flows so automated orchestration remains in sync.

All tools must return structured dictionaries. Results propagate through `AgentState.results`, populate memory, and eventually
persist via Supabase for auditability.
